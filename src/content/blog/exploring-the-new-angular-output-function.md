---
date: 2024-07-06
title: Exploring the New output() Function in Angular
description: Angular has introduced a new way to define output events in components with the output() function. This addition provides a modern and concise alternative to the traditional @Output decorator.
tags: ['angular']
category: Angular
---

:::note
Was introduced on Angular v17.3.0
:::

Angular has introduced a new way to define output events in components with the `output()` function. This addition provides a modern and concise alternative to the traditional `@Output` decorator.

## new output() API

By replacing `@Output` with `output()`, you'll find that your application continues to function seamlessly. This new approach maintains compatibility and offers some additional features.

```ts "output" title="child-component.ts"  del={9,11} ins={10,12}
import { Component, output, OutputEmitterRef, Output } from '@angular/core';

@Component({
  selector: 'child-component',
  standalone: true,
  template: `<button (click)="emitClick($event)">Click here</button>`,
})
export class ChildComponent {
  @Output() deletedClick = new EventEmitter<MouseEvent>();
  deletedClick = output<MouseEvent>();
  @Output('deletedElement') elementDeleted = new EventEmitter<MouseEvent>(); //-> with alias
  elementDeleted = output<MouseEvent>({ alias: 'deletedElement' }); //-> with alias
  emitClick(event: MouseEvent): void {
    this.deletedClick.emit(event);
    this.elementDeleted.emit(event);
  }
}
```

```html
<app-component (deletedClick)="fn($event)" (deletedElement)="fn($event)" />
```

## Key Features

1. **Simplicity**: The `output()` function simplifies the syntax, making the code cleaner and easier to read.
2. **Aliases**: Similar to `@Output`, you can still define aliases for your outputs. While it's not recommended to frequently use aliases, it's important to know that this capability is retained with `output()`.
3. **Backward Compatibility**: Switching to `output()` won't break your existing functionality. Your components will behave just as they did with `@Output`.

## Comparing `OutputEmitterRef` with `EventEmitter`

With the introduction of `output()`, Angular also introduces `OutputEmitterRef`. Let's compare it with the traditional `EventEmitter`.

```ts title="child-component.ts"  del={1} ins={2}
@Output() deletedClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();
deletedClick: OutputEmitterRef<MouseEvent> = output<MouseEvent>();
```

### `EventEmitter`

1. **Purpose**: `EventEmitter` is used to create events that can be emitted and subscribed to. It extends `Subject` and provides methods to emit events.
2. **Methods**: `.emit(value: T)` to emit a value, `.subscribe(handler: Function)` to subscribe to the event.

### `OutputEmitterRef`

1. **Purpose**: `OutputEmitterRef` is an internal type returned by `output()`, simplifying the creation and management of output events.
2. **Methods**: Similar to `EventEmitter`, it includes `.emit(value: T)` to emit a value and `.subscribe(handler: Function)` to handle subscriptions.

:::caution
The subscription generated by this class is not based on **RxJs**, so you can’t use the `pipe()` function and operators. However, it does expose an `unsubscribe()` function to terminate it programmatically. Additionally, it automatically completes when the component or directive is destroyed.
:::

## Subscribing to Outputs Programmatically

Subscribing to outputs programmatically remains straightforward with the new `output()` function. Here’s how you can do it:

```ts title="parent-component.ts"  del={10,12,23-27} ins={11,13,15-21}
import { Component, Signal, effect, viewChild, ViewChild } from '@angular/core';
import { ChildComponent } from './child-component';

@Component({
  selector: 'parent-component',
  standalone: true,
  imports: [ChildComponent],
  template: `<child-component />`,
})
export class ParentComponent implements AfterViewInit {
export class ParentComponent {
  @ViewChild(ChildComponent) myComponentRef!: ChildComponent;
  myComponentRef: Signal<ChildComponent> = viewChild.required(ChildComponent);

  constructor() {
    effect(() => {
      this.myComponentRef().deletedClick.subscribe((event: MouseEvent) => {
        console.log('Event received:', event);
      });
    });
  }

  ngAfterViewInit() {
    this.myComponentRef.deletedClick.subscribe((event: MouseEvent) => {
      console.log('Event received: ', event);
    });
  }
}
```

it automatically completes when the component or directive is destroyed.

## New RxJS-Interop Functions

Two additional functions have been introduced in the RxJs Interop package to further enhance the capabilities of this new API.

### `outputFromObservable()`

With the brand new `outputFromObservable()` function, you can now create an output directly from an Observable.

```ts "outputFromObservable" title="timer.component.ts"
import { Component, OutputRef } from '@angular/core';
import { outputFromObservable } from '@angular/core/rxjs-interop';
import { interval } from 'rxjs';

@Component({
  selector: 'timer-component',
  standalone: true,
  template: `...`,
})
export class TimerComponent {
  timer: OutputRef<number> = outputFromObservable(interval(1000));
  timerAlias = outputFromObservable(interval(1000), { alias: 'timerChange' });
}
```

Both the Observable and the output are automatically completed when the component or directive is destroyed.

If an error occurs, the Observable is interrupted, causing the output to stop emitting and the error to propagate (unless it is caught).

### `outputToObservable()`

With the brand new `outputToObservable()` function, you can now transform an output directly to an Observable.

```ts "outputToObservable" title="parent-component.ts"
import { Component, Signal, effect, viewChild, ViewChild } from '@angular/core';
import { outputToObservable } from '@angular/core/rxjs-interop';
import { ChildComponent } from './child-component';

@Component({
  selector: 'parent-component',
  standalone: true,
  imports: [ChildComponent],
  template: `<child-component />`,
})
export class ParentComponent {
  myComponentRef: Signal<ChildComponent> = viewChild.required(ChildComponent);

  constructor() {
    effect(() => {
      outputToObservable(this.myComponentRef().elementDeleted).subscribe((event: MouseEvent) => {
        console.log('Observable:', event);
      });
    });
  }
}
```

Again, both the Observable and the output are automatically completed when the component or directive is destroyed.

Furthermore, due to the absence of errors in the outputs, the resulting Observable never emits error notifications.

## Acknowledgment

This post draws inspiration and references from [source post](https://dev.to/davidepassafaro/angular-new-output-function-44f1), providing valuable insights into Angular's new `output()` function and related concepts. Special thanks to the original author for their contributions to the Angular community.

## Source Code

You can find the source code for this post on [GitHub](https://github.com/arias9306/blog-src/blob/main/apps/output/src/app/app.component.ts), which includes examples and additional details discussed here.

## Conclusion

The introduction of the `output()` function, `OutputEmitterRef`, and new **RxJS** interop functions in Angular provides a more streamlined way to handle output events and integrate reactive programming.
